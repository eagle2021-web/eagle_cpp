```cpp


void execute_cgi(int client,const char *path,const char *method,const char
*query_string)
{
    char buf[1024];
    ／／缓冲区
    int cgi_output[2];
    int cgi_input[2];
    pid_t pid;
    int status,i;
    char c;
    int numchars =1;
    ／／读取的字符数
    int content_length = -1;
    ／／HTTP的content＿length
    ／／首先需要根据请求是GET还是POST来分别进行处理
            buf[0] = 'A'; buf[1]='\0';
    ／／忽略大小写比较字符串
    if （strcasecmp （method，＂GET＂）＝＝0） ／／如果是GET，那么就忽略剩余的请求头
    ／＊读取数据，把整个header都读取，因为GET直接读取index.html，没有必要分析余下的HTTP
    信息了，即把所有的HTTP header读取并丢弃＊／
    while ((numchars > 0) && strcmp("\n", buf))
        numchars = get_line(client, buf, sizeof(buf));
    else
    ／／如果是POST，那么就需要读出请求长度即Content-Length
            {
                    numchars = get_line(client, buf, sizeof(buf));
            while ((numchars > 0) && strcmp("\n", buf))
            {
                ／＊如果是POST请求，就需要得到Content-Length，Content-Length：这个字符串一共长为15位，
                所以取出头部一句后，将第16位设置结束符，进行比较第16位置为结束＊／
                buf[15]='\0';
                ／／使用＼0进行分割
                if （strcasecmp（buf， ＂Content-Length：＂）＝＝0）／／HTTP请求的特点
                content＿length ＝ atoi（＆（buf［16］））；／／内存从第17位开始就是长度，将
                17位开始的所有字符串转成整数就是content＿length
                numchars = get_line(client, buf, sizeof(buf));
                {
                    ／／如果请求长度不合法（比如根本就不是数字），那么就报错，即没有找到content＿length
                    if (content_length == -1) {
                        bad_request(client);
                        return;
                    }
                    イし
                            sprintf(buf, "HTTP/1.0 200 OK\r\n");
                    send(client, buf, strlen(buf),0);
                    ／／建立output管道
                    if (pipe(cgi_output) <0) {
                        cannot execute(client);
                        return;}
                    ／／建立input管道
                    if (pipe(cgi_input) < 0) {
                        cannot_execute(client);
                        return;
                        {
                            fork后管道都复制了一份，都是一样的
//
                            子进程关闭2个无用的端口，避免浪费
                                                    //
//
//
//
                            父进程关闭2个无用的端口，避免浪费
                            output
//
//
                            input
                            此时父子进程已经可以通信
//
                            ／／fork进程，子进程用于执行cgi
                            ／／父进程用于接收数据以及发送子进程处理的回复数据
                            if ((pid = fork())<0){
                                cannot_execute(client);
                                return;
                            }
                            if (pid ==0) /* child: CGI script */
                            {
                                char meth_env[255];
                                char query_env[255];
                                char length_env[255];
                                ／／子进程输出重定向到output管道的1端
                                        dup2 (cgi_output[1],1);
                                ／／子进程输入重定向到input管道的0端
                                        dup2(cgi_input [0],0);
                                ／／关闭无用管道口
                                        close(cgi_output[0]);
                                close(cgi_input [1]);
                                ／／cgi环境变量
                                        sprintf(meth_env, "REQUEST_METHOD=%s",method);
                                putenv(meth_env);
                                if (strcasecmp(method,"GET") == 0) {
                                    sprintf(query_env, "QUERY_STRING=%s", query_string);
                                    putenv(query_env);
                                }
                                else { /* POST */
                                    sprintf(length_env, "CONTENT_LENGTH=%d", content_length);
                                    putenv(length_env);
                                }
                                ／／替换执行path
                                        execl (path, path, NULL);
//int m = execl(path, path, NULL);
                                ／／如果path有问题，例如将HTML网页改成可执行的，但是执行后m为-1
                                ／／退出子进程，管道被破坏，但是父进程还在往里面写东西，触发Program received signal
                                SIGPIPE, Broken pipe
                                        exit(0);
                                {し
                                    else {
/* parent */
                                        ／／关闭无用管道口
                                                close(cgi_output [1]);
                                        close(cgi_input [0]);
                                        if (strcasecmp(method,"POST")==0)
                                            for (i = 0; i < content_length; i++){
                                                ／／得到POST请求数据，写到input管道中，供子进程使用
                                                        recv(client, &c, 1, 0);
                                                write(cgi_input[1], &c, 1);
                                                J
                                                ／／从output管道读到子进程处理后的信息，然后send出去
                                                while (read(cgi_output [0], &c, 1) > 0)
                                                    send(client, &c, 1,0);
                                                ／完成操作后关闭管道
                                                        close(cgi_output [0]);
                                                close(cgi_input [1]);
                                                waitpid（pid， ＆status，0）；／／等待子进程返回

```